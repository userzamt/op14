<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>lesson03</title>

    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-T3c6CoIi6uLrA9TneNEoa7RxnatzjcDSCmG1MXxSR1GAsXEV/Dwwykc2MPK8M2HN" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css">

    <link rel="stylesheet" href="lesson03.css">   
</head>
<body>
<main class="container-lg">
    <header>
        <h1>CSS селекторы. Приоритетность каскадных стилей</h1>
    </header>

    <a class="fs-3" href="../Homework/Homework03/homework03.html">Домашнее задание 03</a>

    <p>Селектор - это формальное описание того элемента или группы элементов, к которым применяется указанное правило стиля.</p>
		<pre>
<span class="tag">selector</span> {
    <span class="property">style</span>: <span class="unit">properties</span>;
}
		</pre>
		<p>Простой селектор представляет собой селектор типа, селектор класса либо <code>id</code>-селектор, за которым могут следовать селекторы псевдоклассов и селекторы атрибутов.</p>

		<section>
			<h2>Часть 1</h2>
			
			<article>
				<h3>Уневарсальный селектор</h3>
				<p>CSS предоставляет универсальный селектор <code>*</code> для выборки всех тегов веб-страницы. Например, если вы хотите, чтобы все отображалось полужирным шрифтом, нужно добавить следующий код:</p>				
				<pre>
<span class="tag">a</span>, <span class="tag">p</span>, <span class="tag">img</span>, <span class="tag">h1</span>, <span class="tag">h2</span>, <span class="tag">h3</span>, <span class="tag">h4</span>, <span class="tag">h5</span> ......</span> {
    <span class="property">font-weight</span>: <span class="unit">bold</span>;
}
				</pre>
				
				<p>Использование символа <code>*</code> - более быстрый способ сообщить CSS о выборке всех HTML-тегов веб-страницы:</p>
				<pre>
<span class="tag">*</span> { <span class="property">font-weight</span>: <span class="unit">bold</span>; }
				</pre>
				
				<blockquote class="info">Пожалуй самый известный случай применение универсального селектора - это отмена внешних и внутрених отступов.
					<pre>
<span class="tag">*</span> {
    <span class="property">padding</span>: <span class="unit">0</span>;
    <span class="property">margin</span>: <span class="unit">0</span>;
}
					</pre>
				</blockquote>
				
				<p>Кроме того, вы можете задействовать универсальный селектор в составе селектора потомков: применяете стиль ко всем тегам-потомкам, подчиненным определенному элементу веб-страницы. Например, <code>.E *</code> выбирает все теги внутри элемента, имеющего атрибут <code>class</code> со значением <code>.E</code>.</p>
				<pre>
<span class="tag">.E *</span> {
   ....
}
				</pre>
				
				
			</article>
			
			<article>
				<h3>Идентификаторы и классы</h3>
				<p>Идентификатор (называемый также «ID селектор») определяет уникальное имя элемента, которое используется для изменения его стиля и обращения к нему через скрипты.</p>
				<pre>
<span class="tag">#E</span> {
    <span class="property">style</span>: <span class="unit">properties</span>;
}
				</pre>
				
				<p>При описании идентификатора вначале указывается символ решётки (#), затем идет имя идентификатора. Оно должно начинаться с латинского символа и может содержать в себе символ дефиса (-) и подчеркивания (_).</p>
				
				<p>Классы применяют, когда необходимо определить стиль для индивидуального элемента веб-страницы или задать разные стили для одного тега.</p>
				<pre>
<span class="comment">/* Выбирает элемент по значению атрибута class, 
   который может быть использован повторно несколько раз на одной странице */</span>
<span class="tag">E.class</span> {
    <span class="property">style</span>: <span class="unit">properties</span>;
}
<span class="comment">/* так же доступно другое написание; без указания имени тэга */</span>
<span class="tag">.class</span> {
    <span class="property">style</span>: <span class="unit">properties</span>;
}
				</pre>
				
				<p>Классы удобно использовать, когда нужно применить стиль к разным элементам веб-страницы: ячейкам таблицы, ссылкам, абзацам и др.</p>
				<p>Пользовательское имя класса начинается с точки. Имена классов должны начинаться с латинского символа и могут содержать в себе символ дефиса (-) и подчеркивания (_).</p>
				
				<blockquote class="warn">К любому тегу одновременно можно добавить несколько классов, перечисляя их в атрибуте class через пробел. В этом случае к элементу применяется стиль, описанный в правилах для каждого класса. Поскольку при добавлении нескольких классов они могут содержать одинаковые стилевые свойства, но с разными значениями, то берётся значение у класса, который описан в коде ниже.</blockquote>
				
				<blockquote class="warn">В стилях также допускается использовать запись вида <code>.class1.class2</code>, где <code>class1</code> и <code>class2</code> представляют собой имена классов. Стиль применяется только для элементов, у которых одновременно заданы классы <code>class1</code> и <code>class2</code>.</blockquote>
				
			</article>
			
			<article>
				<h3>Контекстные селекторы или селекторы потомка</h3>
				<p>При создании веб-страницы часто приходится вкладывать одни теги внутрь других. Чтобы стили для этих тегов использовались корректно, помогут селекторы, которые работают только в определённом контексте. Например, задать стиль для тега <code>&lt;b&gt;</code> только когда он располагается внутри контейнера <code>&lt;p&gt;</code>. Таким образом можно одновременно установить стиль для отдельного тега, а также для тега, который находится внутри другого.</p>
				
				<pre>
<span class="tag">p b</span> {
    <span class="property">font-weight</span>: <span class="unit">600</span>;
}
				</pre>
				
				<p>Потомок не обязательно должен идти сразу после предка в дереве документа, вроде отношения родитель-ребёнок, но может находиться в любом месте внутри предка. Селекторы потомка создаются пробелом между отдельными элементами в селекторе, создавая новый уровень иерархии для каждого элемента списка.</p>
				
				<pre>
<span class="tag">article p</span> {
    <span class="property">color</span>: <span class="unit">#f0b</span>;
}
				</pre>
				
				<p><a href="exmple/exmple1.html">Пример 1&nbsp;&rarr;</a></p>
				
			</article>
			
			<article>
				<h3>Прямой дочерние селекторы</h3>
				<p>Порой селекторы потомка заходят слишком далеко, выбирая больше, чем хотелось бы. Иногда должны быть выбраны только прямые дети родительского элемента, а не каждый экземпляр элемента вложенный глубоко внутри предка. В этом случае может быть использован прямой дочерний селектор путём размещения знака больше (>) между родительским и дочерним элементом в селекторе.</p>
				
				<p>Например, <code>article > p</code> является прямым дочерним селектором только когда элементы <code>&lt;p&gt;</code> находятся непосредственно внутри элемента <code>&lt;article&gt;</code>. Любой элемент <code>&lt;p&gt;</code> размещённый вне элемента <code>&lt;article&gt;</code> или вложенный внутри другого элемента, кроме <code>&lt;article&gt;</code>, не будет выбран.</p>
				<pre>
<span class="tag">article > p</span> {
    <span class="property">opacity</span>: <span class="unit">0.5</span>;
}
				</pre>
				
				<p><a href="exmple/exmple2.html">Пример 2&nbsp;&rarr;</a></p>
				
			</article>
			
			<article>
				<h3>Соседние селекторы</h3>
				<p>Соседними называются элементы веб-страницы, когда они следуют непосредственно друг за другом в коде документа. Рассмотрим несколько примеров отношения элементов.</p>
				<pre>
&lt;<span class="tag">p</span>&gt;Lorem ipsum &lt;<span class="tag">b</span>&gt;dolor&lt;/<span class="tag">b</span>&gt; sit amet.&lt;/<span class="tag">p</span>&gt;
				</pre>
				
				<p>В этом примере тег <code>&lt;b&gt;</code> является дочерним по отношению к тегу <code>&lt;p&gt;</code>, поскольку он находится внутри этого контейнера. Соответственно <code>&lt;p&gt;</code> выступает в качестве родителя <code>&lt;b&gt;</code>.</p>
				<pre>
&lt;<span class="tag">p</span>&gt;Lorem ipsum &lt;<span class="tag">b</span>&gt;dolor&lt;/<span class="tag">b</span>&gt; &lt;<span class="tag">var</span>&gt;sit&lt;/<span class="tag">var</span>&gt; amet.&lt;/<span class="tag">p</span>&gt;
				</pre>

				<p>Здесь теги <code>&lt;var&gt;</code> и <code>&lt;b&gt;</code> никак не перекрываются и представляют собой соседние элементы. То, что они расположены внутри контейнера <p>, никак не влияет на их отношение.</p>
				<pre>
&lt;<span class="tag">p</span>&gt;Lorem &lt;<span class="tag">b</span>&gt;ipsum&lt;/<span class="tag">b</span>&gt; dolor sit amet, &lt;<span class="tag">var</span>&gt;consectetuer&lt;/<span class="tag">var</span>&gt; adipiscing &lt;<span class="tag">i</span>&gt;elit&lt;/<span class="tag">i</span>&gt;.&lt;/<span class="tag">p</span>&gt;
				</pre>

				<p>Соседними здесь являются теги <code>&lt;b&gt;</code> и <code>&lt;var&gt;</code>, а также <code>&lt;var&gt;</code> и <code>&lt;i&gt;</code>. При этом <code>&lt;b&gt;</code> и <code>&lt;i&gt;</code> к соседним элементам не относятся из-за того, что между ними расположен контейнер <code>&lt;var&gt;</code>.</p>

				<p>Для управления стилем соседних элементов используется символ плюса (+), который устанавливается между двумя селекторами. Общий синтаксис следующий.</p>
				<pre>
<span class="tag">selector1 + selector2</span> {
    <span class="property">style</span>: <span class="unit">properties</span>;
}
				</pre>
				
				<p><a href="exmple/exmple3.html">Пример 3&nbsp;&rarr;</a></p>

				<p>Пробелы вокруг плюса не обязательны, стиль при такой записи применяется к <code>selector2</code>, но только в том случае, если он является соседним для <code>selector1</code> и следует сразу после него.</p>	
			</article>
			
			<article>
				<h3>Сестринские или сиблинговые селекторы</h3>
				<p>Так же в литературе именуется как "правые соседи".</p>
				
				<pre>
<span class="tag">E ~ F</span> {
    <span class="property">style</span>: <span class="unit">properties</span>;
}
				</pre>
				<p>Этот CSS-селектор очень похож на соседний селектор(<code>E + F</code>), однако, является менее строгим. При использовании соседнего селектора <code>E&nbsp;+&nbsp;F</code> будет выбран только первый элемент <code>F</code>, идущий за <code>E</code>. В данном же случае будут выбраны все элементы <code>F</code>, идущие за <code>E</code>.</p>
				
				<p><a href="exmple/exmple4.html">Пример 4&nbsp;&rarr;</a></p>
				
			</article>			
		</section>
		<!-- *Часть 1 -->
		
		<section>
			<h2>Часть 2. Селекторы атрибутов</h2>
			<p>Чтобы гибко управлять стилем подобных элементов, в CSS введены селекторы атрибутов. Они позволяют установить стиль по присутствию определённого атрибута тега или его значения.</p>
			
			<article>
				<h3>Селектор наличия атрибута</h3>
				<p>Первый селектор атрибута определяет элемент на основе того, включен ли этот атрибут или нет, независимо от его фактического значения. Чтобы выбрать элемент основываясь на том, присутствует атрибут или нет, просто включите имя атрибута в квадратных скобках (<code>[]</code>) в селекторе. Квадратные скобки могут идти после любого селектора типа или класса, в зависимости от желаемого уровня специфичности.</p>
				<pre>
<span class="tag">E[foo]</span> { .... }
<span class="comment">/* так же доступна запись */</span>
<span class="tag">[foo]</span> { .... }
				</pre>
				
				<p>В первом случаи стиль применяется к тегу <code>E</code> в которых определён атрибут <code>foo</code>. Во втором случаи,стиль применяется ко всем тегам, внутри которых добавлен указанный атрибут. </p>
				
				<pre>
<span class="comment">/* если для абзаца задан пользовательский атрибут - сделать абзац жирным */</span>
<span class="tag">p[data-my]</span> { 
   <span class="property">font-weight</span>: <span class="unit">600</span>;
}
				</pre>
				
				<p class="s-attr" data-my="example">В теге данного абзаца задан пользовательский атрибут</p>
				<p class="s-attr" data-my="">В теге данного абзаца задан пользовательский атрибут НО он ПУСТОЙ</p>
				
			</article>
			
			<article>
				<h3>Атрибут со значением</h3>
				<p>Устанавливает стиль для элемента в том случае, если задано определённое значение специфичного атрибута.</p>
				<pre>
<span class="tag">E[foo="bar"]</span> { .... }
<span class="comment">/* так же доступна запись */</span>
<span class="tag">[foo="bar"]</span> { .... }
				</pre>
				
				<p>Для идентификации элемента с определённым и точно заданным значением может быть использован тот же селектор что и раньше, однако на этот раз внутри квадратных скобок после имени атрибута включают желаемое значение. Внутри квадратных скобок должно быть имя атрибута, далее знак равно (<code>=</code>), а потом кавычек, где и пишется желаемое значение атрибута.</p>
				<pre>
<span class="tag">a[href="https://yandex.ru"]</span> {
    <span class="property">background-color</span>: <span class="unit">yellow</span>; <span class="comment">/* зададим жёлтый фон для всех ссылок на Яндекс */</span>
}
				</pre>
				
				<ul id="s-attr-value">
					<li><a href="https://yandex.ru">Яндекс</a></li>
					<li><a href="https://google.com">Google</a></li>
				</ul>	
				
				
			</article>
			
			<article>
				<h3>Значение атрибута содержит указанный текст</h3>
				<p>Когда мы пытаемся найти элемент на основе части значения атрибута, для не точного совпадения, может быть использован символ звёздочки (<code>*</code>) в квадратных скобках селектора. Звёздочка должна идти сразу после имени атрибута, непосредственно перед знаком равенства. Это означает, что следующее за ним значение только должно появиться или содержаться в значении атрибута.</p>
				<pre>
<span class="tag">E[foo*="bar"]</span> { .... }
<span class="comment">/* так же доступна запись */</span>
<span class="tag">[foo*="bar"]</span> { .... }
				</pre>
				
				<p>При этом мы можем точно и не знать, в каком месте значения части текста атрибута находится - в начале, середине или конце.</p>
				
				<pre>
<span class="tag">a[href*="login"]</span> {
    <span class="property">font-weight</span>: <span class="unit">600</span>; <span class="comment">/* зададим жирное начертание для ссылок, в адресе которых надоится данная подстрока */</span>
}
				</pre>	
				
			</article>
			
			<article>
				<h3>Значение атрибута начинается с определённого текста</h3>
				<p>В дополнение к выбору элемента на основе того, что значение атрибута содержит указанный текст, можно также выбрать элемент, основанный на том, с чего начинается значение атрибута. Использование символа циркумфлекса (<code>^</code>) в квадратных скобках селектора между именем атрибута и знаком равенства означает, что значение атрибута должно начинаться с указанного текста.</p>
				<pre>
<span class="tag">E[foo^="bar"]</span> { .... }
<span class="comment">/* так же доступна запись */</span>
<span class="tag">[foo^="bar"]</span> { .... }
				</pre>
				
				<pre>
<span class="tag">a[href^="https://"]</span> {
    <span class="property">color</span>: <span class="unit">green</span>; <span class="comment">/* сделаем зелёным ссылки указывающие на защищённые сайты */</span>
}
				</pre>				
			</article>
			
			<article>
				<h3>Значение атрибута оканчивается определённым текстом</h3>
				<p>Противоположностью предыдущего селектора является селектор атрибутов, где значение оканчивается определённым текстом. Вместо использования символа <code>^</code> применяется знак доллара (<code>$</code>) в квадратных скобках селектора между именем атрибута и знаком равенства. Использование знака доллара означает, что значение атрибута должно заканчиваться указанным текстом.</p>
				<pre>
<span class="tag">E[foo$="bar"]</span> { .... }
<span class="comment">/* так же доступна запись */</span>
<span class="tag">[foo$="bar"]</span> { .... }
				</pre>
				
				<p>Таким способом можно автоматически разделять стиль для ссылок на сайты домена <code>ru</code> и для ссылок на сайты других доменов вроде <code>com</code>.</p>
				<pre>
<span class="tag">a[href$=".ru"]</span> {
    <span class="property">background</span>: <span class="unit">url(images/ru.png) no-repeat 0 6px;</span>;
    <span class="property">padding-left</span>: <span class="unit">12px</span>;
}
				</pre>
				
				<p>Стилевые свойства будут применяться только для тех ссылок, атрибут <code>href</code> которых оканчивается на «.ru». Заметьте, что добавив к имени домена слэш (http://www.yandex.ru/) или адрес страницы (http://www.yandex.ru/fun.html), мы изменим тем самым окончание и стиль применяться уже не будет. В этом случае лучше воспользоваться селектором, у которого заданный текст встречается в любом месте значения атрибута.</p>
				
			</article>
			
			<article>
				<h3>Одно из нескольких значений атрибута</h3>
				<p>Некоторые значения атрибутов могут перечисляться через пробел, например имена классов. Чтобы задать стиль при наличии в списке требуемого значения применяется следующий синтаксис.</p>
				<pre>
<span class="tag">E[foo~="bar"]</span> { .... }
<span class="comment">/* так же доступна запись */</span>
<span class="tag">[foo~="bar"]</span> { .... }
				</pre>
				
				<p>Стиль применяется в том случае, если у атрибута имеется указанное значение или оно входит в список значений, разделяемых пробелом.</p>
				<pre>
<span class="tag">a[class~="tag"]</span> { .... }
				</pre>
				
				<pre>
&lt;<span class="tag">a <span class="attr">href</span>="<span class="val">/</span>" <span class="attr">class</span>="<span class="val">tag nofollow</span>"</span>> .... &lt;/<span class="tag">a</span>>
				</pre>
			</article>
			
			<article>
				<h3>Дефис в значении атрибута</h3>
				<p>В именах идентификаторов и классов разрешено использовать символ дефиса (<code>-</code>), что позволяет создавать значащие значения атрибутов <code>id</code> и <code>class</code>. Для изменения стиля элементов, в значении которых применяется дефис, следует воспользоваться следующим синтаксисом.</p>
				<pre>
<span class="tag">E[foo|="bar"]</span> { .... }
<span class="comment">/* так же доступна запись */</span>
<span class="tag">[foo|="bar"]</span> { .... }
				</pre>
				
				<p>Когда значение атрибута разделено дефисом, а не пробелами, может быть использован символ вертикальной линии (<code>|</code>) в квадратных скобках селектора между именем атрибута и знаком равенства. Вертикальная линия означает, что значение атрибута может быть разделено дефисом, однако слова должны начинаться с указанного значения.</p>
				<pre>
<span class="tag">[lang|="en"]</span> { .... } <span class="comment">/* примениться ко всем тэгам где определён данный атрибут и начинается на en */</span>
				</pre>
				
			</article>
					
		</section>
		<!-- *Часть 2. Селекторы атрибутов -->
		
		<section>
			<h2>Часть 3. Псевдоклассы</h2>
			<p>Псевдоклассы определяют динамическое состояние элементов, которое изменяется с помощью действий пользователя, а также положение в дереве документа. Примером такого состояния служит текстовая ссылка, которая меняет свой цвет при наведении на неё курсора мыши. При использовании псевдоклассов браузер не перегружает текущий документ, поэтому с помощью псевдоклассов можно получить разные динамические эффекты на странице.</p>
			<pre>
<span class="tag">selector:pseudoclass</span> {
    <span class="property">style</span>: <span class="unit">properties</span>;
}
			</pre>
			
			<p>Вначале указывается селектор, к которому добавляется псевдокласс, затем следует двоеточие, после которого идёт имя псевдокласса. Допускается применять псевдоклассы к именам идентификаторов или классов, а также к контекстным селекторам. Если псевдокласс указывается без селектора впереди, то он будет применяться ко всем элементам документа.</p>
			
			<article>
				<h3>Псевдоклассы ссылок</h3>
				<p>Псевдоклассы включают в себя два псевдокласса, относящиеся к ссылкам. Это псевдоклассы <code>:link</code> и <code>:visited</code> и они определяют, что ссылка была или не была посещена. Чтобы задать стиль ссылки, которая ещё не была посещена, в игру вступает псевдокласс <code>:link</code>, а псевдокласс <code>:visited</code> задаёт стиль ссылок, которые пользователь уже посетил на основе их истории просмотра.</p>
				
				<pre>
<span class="tag">a:link</span> {
    <span class="property">color</span>: <span class="unit">rgba(0,0,0, 0.5)</span>;
}

<span class="tag">a:visited</span> {
    <span class="property">color</span>: <span class="unit">rgba(255,50,50, 0.5)</span>;
}
				</pre>
				
				<p><a id="pseudo-visited" href="">Ссылка с <code>:visited</code></a></p>
				
				<blockquote class="info">Запись <code>A {...}</code> и <code>A:link {...}</code> по своему результату равноценна, поскольку в браузере даёт один и тот же эффект, поэтому псевдокласс <code>:link</code> можно не указывать. Исключением являются якоря, на них действие <code>:link</code> не распространяется.</blockquote>
				
			</article>
			
			<article>
				<h3>Псевдоклассы действия пользователя</h3>
				<p>К элементу могут динамически применяться основанные на действиях пользователей разные псевдоклассы, которые включают в себя <code>:hover</code>, <code>:active</code> и <code>:focus</code>. 
				<p>Псевдокласс <code>:hover</code> применяется к элементу, когда пользователь двигает курсор над элементом, наиболее часто это используется со ссылками.</p>
				
				<p>Псевдокласс <code>:active</code> применяется к элементу, когда пользователь приводит в действие элемент, например, при щелчке по нему.</p>
				
				<blockquote class="warn"> Несмотря на то, что активным может стать практически любой элемент веб-страницы, псевдокласс <code>:active</code> используется преимущественно для ссылок.</blockquote>
				
				<p><a id="pseudo-active" href="">Пример ссылки с <code>:active</code></a></p>
				
				<p>И, наконец, псевдокласс <code>:focus</code> применяется к элементу, когда пользователь сделал элемент точкой внимания страницы, часто с помощью клавишы <code>Tab</code>, переходя от одного элемента к другому.</p>
				<form>
					<fieldset>
						<legend>Example works :focus</legend>
						<input type="text" value="Black text">
						<input id="pseudo-focus" type="text" value="Black text">
					</fieldset>
				</form>					
			</article>
			
			<article>
				<h3>Псевдоклассы пользовательского интерфейса</h3>
				<p>Подобно ссылкам существуют также некоторые псевдоклассы, связанные с состоянием элементов пользовательского интерфейса, в частности, внутри форм. Эти псевдоклассы включают в себя <code>:enabled</code>, <code>:disabled</code>, <code>:checked</code> и <code>:indeterminate</code>.</p>
				
				<p>Псевдокласс <code>:enabled</code> выбирает поля, которые включены и доступны для использования, а псевдокласс <code>:disabled</code> выбирает поля, которые содержат привязанный к ним атрибут <code>disabled</code>. Многие браузеры по умолчанию затемняют такие заблокированные поля для информирования пользователей о том, что поле не доступно для взаимодействия, однако их стиль может быть настроен по желанию через псевдокласс <code>:disabled</code>.</p>				
				<pre>
<span class="tag">input:enabled</span> { .... }

<span class="tag">input:disabled </span> {
    <span class="property">margin</span>: <span class="unit">10px</span>;
    <span class="property">box-shadow</span>: <span class="unit">0 0 10px rgba(0,0,0, 0.5)</span>;
}
				</pre>
				
				<p>Последние два элемента состояния интерфейса, псевдоклассы <code>:checked</code> и <code>:indeterminate</code> вращаются вокруг флажков и переключателей. Псевдокласс <code>:checked</code> выбирает флажки или переключатели, которые, как вы можете ожидать, помечены. Когда ни один флажок или переключатель не помечен и не выбран, то он живёт в неопределённом состоянии, для которого может быть использован псевдокласс <code>:indeterminate</code> для нацеливания на подобные элементы.</p>
				<pre>
<span class="tag">input:indeterminate</span> { .... }

<span class="tag">input:checked </span> {
    <span class="property">width</span>: <span class="unit">3vh</span>;
    <span class="property">height</span>: <span class="unit">3vh</span>;
    <span class="property">box-shadow</span>: <span class="unit">0 0 10px rgba(0,0,0, 0.5)</span>;
}
				</pre>
				
				<form id="pseudo-ui">
					<fieldset>
						<legend>Псевдокласс UI</legend>
						<label>Text</label><input type="text"><br>
						<label>Disable</label><input type="text" value="Im disabled" disabled><br>
						<label>Checkbox</label><input type="checkbox"><br>
					</fieldset>
				</form>
			</article>
			
			<article>
				<h3>Псевдоклассы, имеющие отношение к дереву документа</h3>
				<p>К этой группе относятся псевдоклассы, которые определяют положение элемента в дереве документа и применяют к нему стиль в зависимости от его статуса.</p>
				<p>Эти псевдоклассы приходят в разных формах и размерах, каждый из которых обеспечивает свою собственную уникальную функцию. Некоторые псевдоклассы существуют уже дольше других, однако CSS3 принёс целый новый набор псевдоклассов в дополнение к существующим.</p>
				
				<!-- H4 -->
				<h4><code>:first-child</code>, <code>:last-child</code> и <code>:only-child</code></h4>
				<p>Первые структурные псевдоклассы, которые вам скорее всего попадутся, это <code>:first-child</code>, <code>:last-child</code> и <code>:only-child</code>. Псевдокласс <code>:first-child</code> выберет элемент, если это первый ребёнок в родителе, в то время как псевдокласс <code>:last-child</code> выберет элемент, если он последний в родителе. Эти псевдоклассы идеально подходят для выбора первого или последнего элемента в списке и др. Кроме того, <code>:only-child</code> выберет элемент, если он является единственным элементом в родителе. 
				
				<pre>
<span class="tag">p b:first-child</span> { 
    <span class="property">color</span>: <span class="unit">green</span>;
    <span class="property">text-transform</span>: <span class="unit">uppercase</span>;
}

<span class="tag">p b:last-child</span> {
    <span class="property">color</span>: <span class="unit">red</span>;
    <span class="property">text-transform</span>: <span class="unit">uppercase</span>;
}
				</pre>
				
				<!-- :only-child не сработает <i> не единственный тэг в родителе -->
				<p id="pseudo-child">Душа моя озарена <b>неземной</b> радостью, <b>как</b> эти <i>чудесные</i> весенние утра, которыми <b>я</b> наслаждаюсь <b>от</b> всего сердца.</p>
				
				<pre>
<span class="tag">p b:only-child</span> { 
    <span class="property">font-weight</span>: <span class="unit">600</span>;
    <span class="property">color</span>: <span class="unit">hsl(190, 60%, 70%)</span>;
    <span class="property">text-transform</span>: <span class="unit">uppercase</span>;
}
				</pre>
				<p id="pseudo-only">Душа моя озарена неземной радостью, как эти <i>чудесные</i> весенние утра, которыми я наслаждаюсь от всего сердца.</p>
				<!-- *H4 -->
				
				<!-- H4 -->
				<h4><code>:first-of-type</code>, <code>:last-of-type</code> и <code>:only-of-type</code></h4>
				<p>Нахождение первого, последнего и единственного ребёнка у родителя очень полезно и часто только это и требуется. Однако иногда вы хотите выбрать только первого, последнего или единственного ребёнка определённого типа элемента. К примеру, вы желаете выбрать только первый или последний абзац внутри статьи или, возможно, только изображение в статье. К счастью, в этом помогают псевдоклассы <code>:first-of-type</code>, <code>:last-of-type</code> и <code>:only-of-type</code>.</p>

				<p>Псевдокласс <code>:first-of-type</code> выберет первый элемент своего типа внутри родителя, в то время как псевдокласс <code>:last-of-type</code> выберет последний элемент этого типа внутри родителя. Псевдокласс <code>:only-of-type</code> выберет элемент, если он является единственным такого типа в родителе.</P>
				
				<pre>
<span class="tag">div p:first-of-type</span> { 
    <span class="property">color</span>: <span class="unit">green</span>;
    <span class="property">text-transform</span>: <span class="unit">uppercase</span>;
}

<span class="tag">div p:last-of-type</span> {
    <span class="property">color</span>: <span class="unit">red</span>;
    <span class="property">text-transform</span>: <span class="unit">uppercase</span>;
}

<span class="tag">div img:only-of-type</span> {
    <span class="property">border</span>: <span class="unit">thin solid #000</span>;
}
				</pre>
				
				<div id="pseudo-type">
					<p>Душа моя озарена неземной радостью, как эти чудесные весенние утра, которыми я наслаждаюсь от всего сердца. Я совсем один и блаженствую в здешнем краю, словно созданном для таких, как я.</p>
					<p>Я так счастлив, мой друг, так упоен ощущением покоя, что искусство мое страдает от этого. Ни одного штриха не мог бы я сделать, а никогда не был таким большим художником, как в эти минуты.</p>
					<img src="http://fakeimg.pl/250x100/">
					<p>Когда от милой моей долины поднимается пар и полдневное солнце стоит над непроницаемой чащей темного леса и лишь редкий луч проскальзывает в его святая святых, а я лежу в высокой траве у быстрого ручья и, прильнув к земле, вижу тысячи всевозможных былинок и чувствую, как близок моему сердцу крошечный мирок, что снует между стебельками, наблюдаю эти неисчислимые, непостижимые разновидности червяков и мошек и чувствую близость всемогущего, создавшего нас по своему подобию, веяние вселюбящего, судившего нам парить в вечном блаженстве, когда взор мой туманится и все вокруг меня и небо надо мной запечатлены в моей душе, точно образ возлюбленной, - тогда, дорогой друг, меня часто томит мысль: "Ах!</p>
					<p>Как бы выразить, как бы вдохнуть в рисунок то, что так полно, так трепетно живет во мне, запечатлеть отражение моей души, как душа моя - отражение предвечного бога!</p>
				</div>

				<p>В приведённом выше примере псевдоклассы <code>div p:first-of-type</code> и <code>div p:last-of-type</code> выберут, соответственно, первый и последний абзацы в статье, независимо от того, являются ли они на самом деле первыми или последними детьми в статье. Селектор <code>div img:only-of-type</code>определяет изображение, как единственное изображение появляющееся в статье.</p>
				<!-- *H4 -->
				
				<!-- H4 -->
				<h4><code>:nth-child(n)</code>, <code>:nth-last-child(n)</code>, <code>:nth-of-type(n)</code> и <code>:nth-last-of-type(n)</code></h4>
				<p>Наконец, есть несколько псевдоклассов структуры и положения, которые выбирают элементы, основанные на номере или алгебраическом выражении. Эти псевдоклассы включают в себя <code>:nth-child(n)</code>, <code>:nth-last-child(n)</code>, <code>:nth-of-type(n)</code> и <code>:nth-last-of-type(n)</code>. Все эти уникальные псевдоклассы начинаются с <code>nth</code> и принимают число или выражение внутри круглых скобок, которое обозначается символом <code>n</code>.</p>
				<p>Число или выражение, которое находится в круглых скобках точно определяет, какой элемент или элементы, должны быть выбраны. Использование конкретного числа вычислит отдельный элемент с начала или с конца дерева документа, а затем выберет его. Использование выражения - вычислит множество элементов с начала или с конца дерева документа и выберет их группу или повторения.</p>
				<p>Так же в каестве значения могут выступать ключевые слова odd - нечётные номера элементов и even -  чётные номера элементов.</p>
				
				
				<table id="t-pseudo-nth">
				<caption>Пример использования <code>:nth</code>- селекторов</caption>
				<tr>
					<th>№</th>
					<th>Фио</th>
					<th>Дата</th>
				</tr>
				<tr>
					<td>1</td>
					<td>Иванов Иван</td>
					<td>2015.10.09</td>
				</tr>
				<tr>
					<td>2</td>
					<td>Петров Пётр</td>
					<td>1985.11.25</td>
				</tr>
				<tr>
					<td>3</td>
					<td>Сидоров Сидр</td>
					<td>2000.03.11</td>
				</tr>
				<tr>
					<td>4</td>
					<td>Максимов Максим</td>
					<td>1999.06.30</td>
				</tr>
				<tr>
					<td>5</td>
					<td>Зайцев Андрей</td>
					<td>1990.08.07</td>
				</tr>
				</table>
				<!-- *H4 -->
				
				<!-- H4 -->
				<h4>Использование чисел и выражений в псевдоклассах</h4>
				<p>Как уже упоминалось, использование конкретного числа в псевдоклассе вычисляет с начала или с конца дерева документа и выбирает один соответствующий элемент. Например, селектор <code>li:nth-child(4)</code> выберет четвёртый пункт в списке. Подсчёт начинается с первого пункта списка и увеличивается на единицу для каждого пункта списка, пока, наконец, не обнаружит четвёртый пункт и выберет его. При указании конкретного числа оно должно быть положительным.</p>

				<p>Выражения для псевдоклассов бывают в формате <code>an</code>, <code>an+b</code>, <code>an-b</code>, <code>n+b</code>, <code>-n+b</code> и <code>-an+b</code>. То же самое выражение может быть переведено и читаться как <code>(a*n)±b</code>. Переменная <code>a</code> обозначает множитель, с учётом которого будут вычисляться элементы, в то время как переменная <code>b</code> обозначает, откуда будет начинаться или происходить отсчёт.</p>

				<p>Например, селектор <code>li:nth-child(3n)</code> будет определять каждый третий элемент пункта списка. Использование этого выражения соответствует 3×0, 3×1, 3×2 и так далее. Как вы можете видеть, результаты этого выражения выбирают третий, шестой и каждый элемент кратный трём</p>

				<p>Кроме того, в качестве значений могут быть использованы ключевые слова <code>odd</code> и <code>even</code>. Как и следовало ожидать, они будут выбирать, соответственно, нечётные или чётные элементы. Если ключевые слова не привлекают, то выражение <code>2n+1</code> выберет все нечётные элементы, а выражение <code>2n</code> выберет все чётные элементы.</p>

				<p>Селектор <code>li:nth-child(4n+7)</code> определит каждый четвёртый пункт списка, начиная с седьмого пункта. Опять же, использование этого выражения эквивалентно (4×0)+7, (4×1)+7, (4×2)+7 и так далее. Результаты этого выражения приведут к выбору седьмого, одиннадцатого, пятнадцатого и каждого четвёртого элемента.</p>

				<p>При использовании аргумента n без числа впереди, переменная a расценивается как равная 1. Селектор <code>li:nth-child(n+5)</code> выберет каждый пункт списка, начиная с пятого, оставив первые четыре пункта списка не выбранными. В выражении это разбирается как (1×0)+5, (1×1)+5, (1×2)+5 и так далее.</p>

				<p>Для создания более сложных вещей могут быть задействованы отрицательные числа. Например, селектор <code>li:nth-child(6n-4)</code> будет отсчитывать каждый шестой пункт списка, начиная с -4, выбрав второй, восьмой, четырнадцатый пункты списка и так далее. Тот же селектор <code>li:nth-child(6n-4)</code> также может быть записан как <code>li:nth-child(6n+2)</code>, без использования отрицательной переменной <code>b</code>.</p>

				<p>Отрицательная переменная или отрицательный аргумент <code>n</code> должен сопровождаться положительной переменной <code>b</code>. Когда аргументу <code>n</code> предшествует отрицательная переменная <code>a</code>, то переменная <code>b</code> определяет, насколько высоко будет достигнут отсчёт. Например, селектор <code>li:nth-child(-3n+12)</code> выберет каждый третий пункт списка в первых двенадцати пунктах. Селектор <code>li:nth-child(-n+9)</code> выберет первые девять пунктов списка, так как переменная <code>a</code> без заявленного числа по умолчанию равна -1.</p>
				<!-- *H4 -->				
			</article>
			
			<article>
				<h3>Комбинация псевдоклассов</h3>
				<p>При стилизации элементов возможна комбинация псевдоклассов, например:</p>
				<pre>
<span class="comment">/* добавит стили при наведении каждой чётной строке таблицы (отсчёт в обратном порядке) */</span>
<span class="tag">tr:nth-last-child(even):hover</span> { ... }
				</pre>
				
			</article>
		</section>
		<!-- *Часть 3. Псевдоклассы -->
		
		<section>
			<h2>Часть 4. Псевдоэлементы</h2>
			<p>Псевдоэлементы — это динамические элементы, которые не существуют в дереве документа и при использовании с селекторами эти псевдоэлементы дают уникальные части страницы, которые можно стилизовать. Один важный момент следует отметить — <mark>только один псевдоэлемент может быть использован в селекторе в определённое время</mark>.</p>
			
			<article>
				<h3>Текстовые псевдоэлементы</h3>
				<p>Первыми реализованными псевдоэлементами были текстовые псевдоэлементы <code>:first-letter</code> и <code>:first-line</code>. Псевдоэлемент <code>:first-letter</code> определяет первую букву текста внутри элемента, в то время как <code>:first-line</code> определяет первую строку текста внутри элемента.</p>
				<pre>
<span class="tag">#elem-letter:first-letter, #elem-line:first-line</span> { 
    <span class="property">color</span>: <span class="unit">#ed1c24</span>;
    <span class="property">font-size</span>: <span class="unit">1.25rem</span>;
}
				</pre>
				
				<p id="elem-letter">Далеко-далеко за словесными горами в стране гласных и согласных живут рыбные тексты. Вдали от всех живут они в буквенных домах на берегу Семантика большого языкового океана.</p>

				<p id="elem-line">Маленький ручеек Даль журчит по всей стране и обеспечивает ее всеми необходимыми правилами. Эта парадигматическая страна, в которой жаренные члены предложения залетают прямо в рот.</p>
				
				<blockquote class="warn">К псевдоэлементу <code>:first-line</code> могут применяться не все стилевые свойства. Допустимо использовать свойства, относящиеся к шрифту, изменению цвет текста и фона, а также: <code>clear</code>, <code>line-height</code>, <code>letter-spacing</code>, <code>text-decoration</code>, <code>text-transform</code>, <code>vertical-align</code> и <code>word-spacing</code>.</blockquote>
				
			</article>
			
			<article>
				<h3>Псевдоэлементы, генерируемые содержимое</h3>
				<p>Псевдоэлементы <code>:before</code> и <code>:after</code> создают новые строчные псевдоэлементы только внутри выбранного элемента. Чаще всего эти псевдоэлементы используются в сочетании со свойством <code>content</code>, чтобы добавить незначительную информацию на страницу, однако, это не всегда так. Дополнительное применение этих псевдоэлементов может добавить компоненты пользовательского интерфейса на страницу без необходимости загромождать документ несемантическими элементами.</p>
				<p>Псевдоэлемент <code>:before</code> создаёт псевдоэлемент до или впереди выбранного элемента, в то время как <code>:after</code> создаёт псевдоэлемент после или позади выбранного элемента. Эти псевдоэлементы выводятся вложенными внутри выбранного элемента, а не за его пределами. Ниже псевдоэлемент <code>:after</code> используется для отображения значения атрибута <code>href</code> у ссылок в круглых скобках после самой ссылки. Такая информация полезна, но, в конечном итоге, не всякий браузер поддерживает эти псевдоэлементы.</p>
				
				<pre>
<span class="tag">#elem-ba a:before</span> { 
    <span class="property">content</span>: <span class="unit">"\21BB "</span>;
    <span class="property">color</span>: <span class="unit">#56a0d3</span>;
}

<span class="tag">#elem-ba a:after</span> { 
    <span class="property">content</span>: <span class="unit">"(" attr(href) ")"</span>;
    <span class="property">color</span>: <span class="unit">rgba(0,0,0, 0.8)</span>;
    <span class="property">font-size</span>: <span class="unit">0.8rem</span>;
}
				</pre>
				
				<ul id="elem-ba">
					<li><a href="https://yandex.ru">Яндекс</a></li>
					<li><a href="https://google.com">Google</a></li>
				</ul>	
						
			</article>
			
			<article>
				<h3>Псевдоэлемент ::selection</h3>
				<p>Псевдоэлемент <code>::selection</code> определяет выделенную пользователем часть документа. Выделение затем может быть стилизовано, но только с помощью свойств <code>color</code>, <code>background</code>, <code>background-color</code> и <code>text-shadow</code>. Стоит отметить, что свойство <code>background-image</code> игнорируется. В то же время сокращённое свойство <code>background</code> может быть использовано для добавления цвета, но любые изображения будут игнорироваться.</p>
				
				<blockquote class="info">
				<h4>Двоеточие (:) и двойное двоеточие (::)</h4>
				<p>Псевдоэлемент <code>::selection</code> был добавлен в CSS3 в попытке отделить псевдоклассы от псевдоэлементов с помощью двойного двоеточия, которое было добавлено к псевдоэлементам. К счастью, большинство браузеров будут поддерживать оба значения, одиночные или двойные двоеточия у псевдоэлементов, однако <mark>псевдоэлемент ::selection всегда должен начинаться с двойного двоеточия</mark>.</p></blockquote>
				
				<p>При выделении любого текста в демонстрации ниже фон становится оранжевым благодаря псевдоэлементу <code>::selection</code>.</p>
				<pre>
<span class="tag">.elem-select p:selection</span> { 
    <span class="property">background</span>: <span class="unit">#ff7b29</span>;
}
				</pre>
				
				<p class="elem-select">Душа моя озарена неземной радостью, как эти чудесные весенние утра, которыми я наслаждаюсь от всего сердца.</p>
				<p class="elem-select">Я совсем один и блаженствую в здешнем краю, словно созданном для таких, как я. Я так счастлив, мой друг, так упоен ощущением покоя, что искусство мое страдает от этого.</p>
				<p class="elem-select">Ни одного штриха не мог бы я сделать, а никогда не был таким большим художником, как в эти минуты.</p>
				<p class="elem-select">Когда от милой моей долины поднимается пар и полдневное солнце стоит над непроницаемой чащей темного леса и лишь редкий луч проскальзывает в его святая святых, а я лежу в высокой траве у быстрого ручья и, прильнув к земле, вижу тысячи всевозможных былинок и чувствую, как близок моему сердцу крошечный мирок, что снует между стебельками, наблюдаю эти неисчислимые, непостижимые разновидности червяков и мошек и чувствую близость всемогущего, создавшего нас по своему подобию, веяние вселюбящего, судившего нам парить в вечном блаженстве, когда взор мой туманится и все вокруг меня и небо надо мной запечатлены в моей душе, точно образ возлюбленной, - тогда, дорогой друг, меня часто томит мысль: "Ах!</p>
				
			</article>
				
		</section>
		<!-- *Часть 4. Псевдоэлементы -->
		
		<section>
			<h2>Префиксы</h2>
			<p>Вендорные префиксы — это приставки к названию CSS свойства, которые добавляют производители браузеров для нестандартизированных свойств.</p>
			
			<table id="t-prefix">
				<caption>Префиксы CSS для браузеров</caption>
				<tr>
					<th>IE</th>
					<th>Chrome</th>
					<th>Opera</th>
					<th>Safari</th>
					<th>Firefox</th>
					<th>Android</th>
					<th>iOS</th>
				</tr>
				<tr>
					<td>-ms-</td>
					<td>-webkit-</td>
					<td>-o-</td>
					<td>-webkit-</td>
					<td>-moz-</td>
					<td>-webkit-</td>
					<td>-webkit-</td>
				</tr>
			</table>
			
			<blockquote class="error">Согласно спецификации CSS 2.1 CSS идентификаторы, которые начинаются с "-" или "_" зарезервированы для CSS расширений браузеров. Наличие этих знаков в начале свойства гарантирует то, что в будущем расширения браузеров никогда не пересекутся со стандартными CSS свойствами. Т.е. ни один браузер не начнет «случайно» понимать свойство, которое для него не предназначено.</blockquote>
			
			<pre>
<span class="tag">div</span> {
    <span class="property">-webkit-transform</span>: <span class="unit">rotate(-45deg)</span>;
       <span class="property">-moz-transform</span>: <span class="unit">rotate(-45deg)</span>;
        <span class="property">-ms-transform</span>: <span class="unit">rotate(-45deg)</span>;
         <span class="property">-o-transform</span>: <span class="unit">rotate(-45deg)</span>;	
            <span class="property">transform</span>: <span class="unit">rotate(-45deg)</span>;	
}
			</pre>
			<p>Браузер из такого кода интерпретирует только то свойства, которое написано под него, а написанные для других браузеров игнорирует.</p>
			
			<p>Причин для появления префиксов было достаточно много:</p>
			<ul>
				<li>Для включения в браузер экспериментальных свойств CSS, которые стандартом ещё не утверждены. Таким образом, производители браузеров производят тестирование и вносят предложения перед утверждением свойств CSS в стандарте.</li>
				<li>Для решения проблем с кроссбраузерностью.</li>
				<li>Для создания собственных свойств, которые не входят в стандарт CSS, но возможно появятся в нём через некоторое время.</li>
			</ul>
			
			<p>Когда экспериментальное свойство утверждено в стандарте и прошло тестирование в браузере, у него обычно убирается префикс.</p>
		</section>
		<!-- *Префиксы -->	
	<a href="Selectors Level 3.pdf" target="_blank" class="d-block pb-1 mb-3">Спецификация по селекторам CSS3</a>
</main>    


<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-C6RzsynM9kWDrMNeT87bh95OGNyZPhcTNXj1NW7RuBCsyN/o0jlpcV8Qyq46cDfL" crossorigin="anonymous"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script>hljs.highlightAll();</script>

</body>
</html>