<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>lesson21</title>

    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-T3c6CoIi6uLrA9TneNEoa7RxnatzjcDSCmG1MXxSR1GAsXEV/Dwwykc2MPK8M2HN" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css">

    <link rel="stylesheet" href="lesson21.css">   
</head>
<body>
<main class="container-lg text-justify">
    <header>
        <h1>Сетевые запросы. Технология AJAX</h1>
    </header>
    
    <p><b>Интернет</b> - всемирная система объединённых компьютерных сетей для хранения и передачи информации(сеть сетей).</p>
    <p>Ресурсы Интернета разбросаны по оборудованию на всем земном шаре. Для связи этого оборудования между собой на огромных расстояниях придумали специальные алгоритмы и стандарты, в частности, стек протоколов TCP/IP, на котором в настоящее время функционирует наш Интернет.</p>
    <p>По стандарту, каждый компьютер, находящийся в Глобальной сети, имеет свой уникальный адрес - IP-адрес. IP-адрес представляет собой последовательность четырех чисел в диапазоне от 0 до 255, разделенных между собой точками.</p>
    <pre>
92.166.31.18
192.168.0.1
    </pre>
    <p>Один компьютер может связаться с другим компьютером в сети, зная его IP-адрес. Но сказать "компьютер связался с компьютером" не совсем верно, так как связываются не сами компьютеры, а сетевые службы (программы), выполняющиеся на них.</p>
    <blockquote class="info">Допустим, мы отправляем письмо по электронной почте, при этом наша почтовая программа связывается с почтовым сервером для отправки письма.</blockquote>
    <p>На компьютере одновременно может работать несколько сетевых программ, поэтому помимо IP-адреса для связи в стеки протоколов TCP/IP предусмотрено дополнительно такое понятие как порт.</p>
    <p><b>Порт</b> - это число в диапазоне от 1 до 65536. Таким образом, минимальным условием для связи одной сетевой программы с другой является наличие у первой IP-адреса и номера порта второй. Совокупность IP-адреса и порта принято записывать через двоеточие.</p>
    <pre>
92.166.31.18<span class="port">:8080</span>
192.168.0.1<span class="port">:443</span>
    </pre>
    <p>Для установления связи первой программе задается номер порта и она начинает "ожидать" подключение второй. Второй программе указывается тот же самый номер порта и IP-адрес компьютера, на котором запущена первая программа. Это своего рода связь звонок по сотовому телефону, где номер телефона это совокупность IP-адреса и порта.</p>
    <p>Программа, ожидающая подключение, называется сервером. Серверу при запуске указывается номер порта, часто говорят: <i>"сервер слушает порт"</i>. <mark>На компьютере не может быть запущено более одного сервера с одинаковым номером порта, иначе невозможно определить, к какому из серверов подключаться</mark>. Программа, устанавливающая соединение с сервером, называется клиентом. На клиентов не распространяется подобное ограничение. К примеру, по этому на клиенте можно запустить более одного IRC-клиента. Также к серверу могут подключаться несколько клиентов с разных компьютеров, если это конечно поддерживает сам сервер.</p>
    <p><b>Веб-сервер</b> - это сетевая программа, ожидающая и принимающая запросы от клиентов и выдающий им HTTP-ответы, как правило, вместе с HTML-страницей, изображением, файлами, медиа-потоком или другими данными. По умолчанию, веб-сервер "слушает" порт под номером 80. Клиентом для веб-сервера выступает веб-браузер.</p>
    <p>Сайт функционирует за счет веб-сервера, который отправляет странички этого сайта клиентам, запрашивающих их у него. Для того, чтобы запросить страницу необходимо знать IP-адрес компьютера, на котором запущен веб-сервер с нужным нам сайтом. Но запоминать IP-адреса неудобно, поэтому придумали доменные имена, представляющие собой некую текстовую сущность.</p>
    <pre>
yandex.ru
vk.com
    </pre>
    <p>Доменные имена более понятны и более легки в запоминании. Однако, протокол TCP/IP не в состоянии найти требуемый компьютер по доменному имени, поэтому его необходимо преобразовать в IP-адрес. Для этого служат DNS-сервера, на которых расположены таблицы соответствий доменных имен и IP-адресов. Допустим, когда мы вводим в адресной строке браузера домен yandex.ru, в первую очередь посылается запрос на DNS-сервер для определения IP-адреса данного домена. Когда адрес определен, браузер пытается связаться с веб-сервером по этому адресу и стандартному порту 80. Если соединение с веб-сервером установлено, браузер запрашивает у веб-сервера требуемую страницу сайта.</p>
    <figure class="text-center">
            <img src="img/dns-root.svg">
            <figcaption>Расположение корневых DNS-серверов</figcaption>
        </figure>
    <blockquote class="bg-warning bg-gradient p-2 my-1">В принципе, веб-сервер можно настроить на работу и на другом порту, в таком случае в браузере при запросе страницы необходимо его указывать через двоеточие после доменного имени (например, site.ru:8080).</blockquote></p>
    <p>Каким же образом происходит запрос страницы сайта у веб-сервера? Для взаимодействия веб-сервера и браузера существует "общий язык", то есть стандарт, по которому формируются запросы и ответы. Этим стандартом служит протокол HTTP (HyperText Transfer Protocol).</p>
    
    <section>
        <h2><code>HTTP</code></h2>
        <p>Стандарт <a href="http://tools.ietf.org/html/rfc2616" target="blanck">RFC2616 Hypertext Transfer Protocol HTTP/1.1</a></p>
        <p>Стандарт <a href="https://tools.ietf.org/html/rfc7540" target="blanck">RFC7540 Hypertext Transfer Protocol Version 2 (HTTP/2)</a></p>
        <p><b>HTTP</b> ( HyperText Transfer Protocol - «протокол передачи гипертекста») - протокол прикладного уровня передачи данных (изначально - в виде гипертекстовых документов в формате HTML, в настоящий момент используется для передачи произвольных данных). Основой HTTP является технология клиент-сервер.</p>
        <blockquote class="bg-warning p-2 my-1">Когда вы заходите в браузер и вводите в адресную строку адрес к сайту, то браузер автоматически прибавляет к адресу приставку «http://». Единственное, эта приставка может быть по умолчанию скрыта, но если скопировать адрес и вставить его в другое место, то ее без труда можно будет увидеть. Эта приставка обозначает, что вы будете обращаться к ресурсу по протоколу HTTP.</blockquote>
        <p>Этот протокол соответствует схеме "запрос-ответ".На каждый HTTP-запрос браузера веб-сервер отвечает HTTP-ответом. По своей инициативе веб-сервер HTTP-пакеты не шлет, к тому же, зачастую, после завершения операции "запрос-ответ" сервер разрывает соединение с клиентом.</p>
        <figure class="text-center">
            <img src="img/http1-request-response.png">
            <figcaption>Схема запрос-ответ</figcaption>
        </figure>
        <p>Общение между хостом и клиентом происходит в два этапа: запрос и ответ. Клиент формирует HTTP запрос, в ответ на который сервер даёт ответ (сообщение).</p>
        <p>По сути, протокол HTTP - это инструмент, с помощью которого можно передавать веб-страницы в сети Интернет. Веб-страница, которую мы получаем в ответе от сервера, на самом деле это HTML-код, который получает браузер и соответствующим образом его интерпретирует.</p>
        
        <h3>HTTP-сообщения</h3>
        <p>Каждое HTTP-сообщение состоит из трёх частей, которые передаются в указанном порядке:</p>
        <ul>
            <li><b>Стартовая строка</b>(Starting line) - определяет тип сообщения</li>
            <li><b>Заголовки</b>(Headers) - характеризуют тело сообщения, параметры передачи и прочие сведения</li>
            <li><b>Тело сообщения</b>(Message Body) - непосредственно данные сообщения. Обязательно должно отделяться от заголовков пустой строкой.</li>
        </ul>
        <blockquote class="bg-warning bg-gradient p-2 my-1">Заголовки и тело сообщения могут отсутствовать, но стартовая строка является обязательным элементом, так как указывает на тип запроса/ответа.<br>Для версии протокола 1.1, сообщение запроса обязательно должно содержать заголовок Host.</blockquote>
        <figure class="text-center">
            <img src="img/http1-request-response-message.png">
            <figcaption>HTTP-сообщения</figcaption>
        </figure>
        
        <h3>Стартовая строка</h3>
        <p>Стартовые строки различаются для запроса и ответа. Строка запроса выглядит следующим образом</p>
        <pre>
<span class="method">METHOD</span> <span class="uri">URI</span> HTTP/<span class="version">VERSION</span>
        </pre>
        <p><b>Метод</b>(METHOD)- это тип запроса, одно слово заглавными буквами.</p>
        <p><b>URI</b> определяет путь к запрашиваемому документу.</p>
        <p><b>Версия протокола</b>(VERSION) - определяет, в соответствии с какой версией стандарта HTTP составлен запрос(на данный момент актуальная версия 1.1 и по степенно уже внедряется HTTP/2).</p>
        <p>Для того, чтобы обратиться к веб-странице по определённому адресу (в данном случае путь к ресурсу — это «/»), нам следует отправить следующий запрос:</p>
        <pre>
<span class="method">GET</span> <span class="uri">/</span> <span class="version">HTTP/1.1</span>
<span class="caption">Host</span>: ya.ru

<span class="method">GET</span> <span class="uri">/img/adqfcd12.txt</span> <span class="version">HTTP/1.1</span>
<span class="caption">Host</span>: filehost.ru
        </pre>
        <p>Стартовая строка ответа сервера имеет следующий формат</p> 
        <pre>
HTTP/<span class="version">Версия</span> КодСостояния <span class="attr">Пояснение</span> 
        </pre>
        <p><b>Версия протокола</b> - определяет, в соответствии с какой версией стандарта HTTP отправлен ответ(такая же версия как и в запросе).</p>
        <p><b>Код состояния</b>(Status Code) - три цифры (первая из которых указывает на класс состояния), которые определяют результат совершения запроса.</p>
        <p><b>Пояснение</b> к коду состояния(Reason Phrase) - текстовое пояснение к коду ответа, предназначено для упрощения чтения ответа человеком. Пояснение может не учитываться клиентским программным обеспечением, а также может отличаться от стандартного в некоторых реализациях серверного ПО.</p>
        <pre>
<span class="version">HTTP/1.1</span> 200 <span class="attr">ОК</span>
<span class="caption">Server</span>: nginx/1.2.1
<span class="caption">Date</span>: Sat, 08 Mar 2014 22:53:46 GMT
....
        </pre>
        
        <h4>Методы</h4>
        <p>Метод HTTP - это последовательность символов, указывающая на основную операцию над ресурсом. Обычно метод представляет собой короткое английское слово, записанное заглавными буквами. <mark>Обратите внимание, что название метода чувствительно к регистру.</mark></p>
        <p>Наиболее часто используются методы GET и POST</p>
        <blockquote class="bg-warning bg-gradient p-2 my-1">Обратите внимание на тот факт, что спецификация HTTP не обязывает сервер понимать все методы (которых на самом деле гораздо больше, чем 4) — обязателен только GET, а также не указывает серверу, что он должен делать при получении запроса с тем или иным методом. </blockquote>
        
            <h4><code>GET</code></h4>
            <p>Запросы GET соблюдают идепотентность(тождественность). Состояние сервера и данные для приложения не должны измениться под воздействием запроса GET. Один и тоже GET запрос, выполняясь снова и снова, должен возвращать в точности те же самые результаты(предполагается, что в это время не происходит ничего друго, что привело бы к изменению состояния сервера).</p>
            <p>По сути он ипользуется для запроса содержимого указанного ресурса. С помощью метода GET можно также начать какой-либо процесс. В этом случае в тело ответного сообщения следует включить информацию о ходе выполнения процесса.</p>
            <p>HTTP-запрос типа GET состоит только из HTTP-заголовков, тело у него отсутствует.</p>
            <p>При помощи GET-запроса можно передать веб-серверу параметры - некоторую информацию. Например, если  необходимо осуществить поиск по определённым имени, то с помощью параметров можно передавать имя веб-серверу.</p>
            <p>Клиент может передавать параметры выполнения запроса в URI целевого ресурса после символа <code>?</code>(знак вопроса)</p>
            <figure class="text-center">
                <img src="img/http1-url-structure.png">
                <figcaption>Пример из адресной строки браузера</figcaption>
            </figure>
            <pre>
<span class="method">GET</span> <span class="uri">/path/resource?param1=value1&amp;param2=value2</span> <span class="version">HTTP/1.1</span>
<span class="caption">Host</span>: host.local
            </pre>
            <p>Основным преимуществом GET-параметров является их размещение непосредственно в URL, что дает возможность сформировать гиперссылку на документ с определенными параметрами.</p>
            <p>Стоит помнить так же и о длине URL. Она ограничена 1024 символами, это является ограничением для данных, которые можно отослать GET запросом</p>		
            
            <h4><code>POST</code></h4>
            <p>Запросы POST могут быть неидемпотентными(нетождественными). Данные, передаваемые серверу в таких запросах, могут использоваться для изменения состояния приложения, например, для добавления записей в базу данных.</p>
            <p>Основное предназначение POST запроса - это создания нового ресурса. POST запрос обычно содержит в себе всю нужную информацию для создания нового ресурса.</p>
            <p>POST передает данные, используя тело HTTP запроса, в отличии от GET, который может передавать данные используя URI.</p>
            <p>POST может отправлять гораздо большие объемы данных, чем GET запрос. Лимит устанавливается веб-сервером и обычно он колеблется в диапазоне от 2MB до 5MB(это ограничение только на размер одного запроса).</p>
            <p>Передача данных методом POST более безопасна, чем методом GET, так как секретные данные (например пароль) не отображаются напрямую пользователю (в отличии от URI, который виден почти всегда).</p>

            <h4>Коды состояния</h4>
            <p><a href="https://ru.wikipedia.org/wiki/%D0%A1%D0%BF%D0%B8%D1%81%D0%BE%D0%BA_%D0%BA%D0%BE%D0%B4%D0%BE%D0%B2_%D1%81%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D1%8F_HTTP" target="_blanck">Код состояния</a> является частью первой строки ответа сервера. Он представляет собой целое число из трёх цифр. Первая цифра указывает на класс состояния. За кодом ответа обычно следует отделённая пробелом поясняющая фраза на английском языке, которая разъясняет человеку причину именно такого ответа.</p>
            <p>Клиент узнаёт по коду ответа о результатах его запроса и определяет, какие действия ему предпринимать дальше. Набор кодов состояния является стандартом, и они описаны в соответствующих документах. Клиент может не знать все коды состояния, но он обязан отреагировать в соответствии с классом кода.</p>
            <p>Выделено пять классов кодов состояния.</p>
            <ul>
                <li><code>1xx</code> - Информационные</li>
                <li><code>2xx</code> - Успех</li>
                <li><code>3xx</code> - Перенаправление</li>
                <li><code>4xx</code> - Ошибки клиента</li>
                <li><code>5xx</code> - Ошибки сервера</li>
            </ul>
            
        <h3>Заголовки HTTP</h3>
        <p><a href="https://ru.wikipedia.org/wiki/%D0%97%D0%B0%D0%B3%D0%BE%D0%BB%D0%BE%D0%B2%D0%BA%D0%B8_HTTP" target="_blanck">Заголовки HTTP</a> - это строки в HTTP-сообщении, содержащие разделённую двоеточием пару параметр-значение.</p>
        <p>Все заголовки разделяются на четыре основных группы</p>
        <ul>
                <li><code>General Headers</code>(«Основные заголовки») — могут включаться в любое сообщение клиента и сервера</li>
                <li><code>Request Headers</code>(«Заголовки запроса») — используются только в запросах клиента</li>
                <li><code>Response Headers</code>(«Заголовки ответа») — только для ответов от сервера</li>
                <li><code>Entity Headers</code>(«Заголовки сущности») — сопровождают каждую сущность сообщения</li>
            </ul>

        <h3>Тело сообщения</h3>
        <p>Тело сообщения - это, собственно, передаваемые данные. В ответе передаваемыми данными, как правило, является html-страница, которую запросил браузер, а в запросе, например, в теле сообщения передается содержимое файлов, загружаемых на сервер. Но как правило, тело сообщения в запросе вообще отсутствует.</p>
    </section>
    
    <section>
        <h2><code>AJAX</code></h2>
        <p>AJAX (Asynchronous Javascript And Xml) – технология обращения к серверу без перезагрузки страницы. Технология AJAX в основном используется для создания асинхронных запросов к серверу. Асинхронный запрос - это запрос, который выполняется в фоновом режиме и не мешает пользователю взаимодействовать со страницей. За счет этого уменьшается время отклика и веб-приложение по интерактивности больше напоминает десктоп.</p>
        <p>AJAX это подход к построению интерактивных пользовательских интерфейсов веб-приложений, заключающийся в фоновом обмене данными между браузером и веб-сервером.</p>
        <p>Несмотря на то, что в названии технологии присутствует буква X (от слова XML), использовать XML вовсе не обязательно. Под AJAX подразумевают любое общение с сервером без перезагрузки страницы, организованное при помощи JavaScript.</p>
        <figure class="text-center">
                <img src="img/ajax-google-suggest.png">
                <figcaption>Реальный пример использования AJAX</figcaption>
        </figure>
        
            <h3><code>XMLHttpRequest</code></h3>
            <p>Объект <code>XMLHttpRequest</code> (или, как его кратко называют, «XHR») дает возможность из JavaScript делать HTTP-запросы к серверу без перезагрузки страницы.</p>
            <blockquote class="bg-warning bg-gradient p-2 my-1">Несмотря на слово «XML» в названии, <code>XMLHttpRequest</code> может работать с любыми данными, а не только с XML.</blockquote>
            <p>Каждый экземпляр этого класса представляет единственную пару запрос/ответ, а свойства и методы объекта позволяют определять параметры запроса и извлекать данные из ответа.</p>
            <p>Первое, что обычно необходимо сделать при использовании этого прикладного интерфейса к протоколу HTTP, это, разумеется, создать экземпляр объекта <code>XMLHttpRequest</code></p>
            <pre>
<span class="js">var</span> xhr = <span class="js">new</span> XMLHttpRequest();
            </pre>
            <p>Допустимо повторно использовать уже имеющийся экземпляр объекта <code>XMLHttpRequest</code>, но следует иметь в виду, что в этом случае будет прервано выполнение запроса, уже отправленного объектом.</p>
            
            <h3>Настройка <code>.open()</code></h3>
            <p>Следующий этап после создания объекта <code>XMLHttpRequest</code> - определение параметров HTTP-запроса вызовом метода <code>open()</code> объекта <code>XMLHttpRequest</code>, которому передаются две обязательные части запроса: метод и URI</p>
            <pre>
xhr.open(<span class="method">"GET"</span>, <span class="uri">"http://domain.local/img/sample.png"</span>);
            </pre>
            <p>Данный метод – как правило, вызывается первым после создания объекта <code>XMLHttpRequest</code>. Его синтаксис</p>
            <pre>
xhrReq.open(method, url[, async, user, password]);
            </pre>
            <p>С первыми двумя параметрам всё понятно. Третий параметр async - если установлено в <code>false</code>, то запрос производится синхронно, если <code>true</code> – асинхронно.</p>
            <p><b>Синхронный запрос</b> означает, что после вызова <code>xhr.send()</code> и до ответа сервера главный поток будет заморожен: посетитель не сможет взаимодействовать со страницей – прокручивать, нажимать на кнопки и т.п. После получения ответа выполнение продолжится со следующей строки.</p>
            <p><b>Асинхронный запрос</b> означает, что браузер отправит запрос, а далее результат нужно будет получить через обработчики событий, которые мы рассмотрим далее.</p>
            <p>Параметры user, password(опциональны) - логин и пароль для HTTP-авторизации, если нужны.</p>
            <blockquote class="bg-warning bg-gradient p-2 my-1">Заметим, что вызов open, в противоположность своему названию не открывает соединение. Он лишь настраивает запрос, а коммуникация инициируется методом <code>send()</code>.</blockquote>
            
            <h3>Отправка данных <code>.send()</code></h3>
            <p>Последний этап в процедуре выполнения HTTP-запроса с помощью объекта <code>XMLHttpRequest</code> передача необязательного тела запроса и отправка его серверу. Делается это с помощью метода <code>send()</code></p>
            <pre>
xhrReq.send([body]);
            </pre>
            <p>Именно этот метод открывает соединение и отправляет запрос на сервер. </p>
            
            <a href="sample/sample1.html" target="_blanck">Пример отправки AJAX запроса</a> 
            <blockquote class="bg-warning bg-gradient p-2 my-1">После нажатия на кнопку в примере откройте консоль чтобы посмотреть результат</blockquote>
            
            
            <p>GET-запросы не имеют тела, и в этом случае можно передать методу значение <code>null</code> или вообще опустить аргумент. POST-запросы имеют тело, в котором как раз передаются данные.</p>
            
            <h3>Получение ответа</h3>
            <p>Полный HTTP-ответ содержит код состояния, набор заголовков ответа и тело ответа. Все это доступно в виде свойств и методов объекта <code>XMLHttpRequest</code></p>
            <ul>
                <li>Свойства <code>status</code> и  <code>statusText</code> возвращают  код  состояния  HTTP  в  числовом и текстовом  виде.  Эти  свойства  хранят  стандартные  HTTP-значения,  такие как 200 и «OK» в случае успешного выполнения запроса или 404 и «Not Found» при попытке обратиться к ресурсу, отсутствующему на сервере.</li>
                <li>Заголовки ответа можно получить с помощью методов <code>getResponseHeader()</code> и <code>getAllResponseHeaders()</code>.</li>
                <li> Тело ответа в текстовом в де доступно через свойство <code>responseText</code> или в виде объекта <code>Document</code> через  свойство <code>responseXML</code>(выбор  такого  имени  свойства объясняется историческими причинами).</li>
            </ul>
            <p><a href="sample/sample2.html" target="_blanck">Пример 2.</a> </p>
            <p><a href="sample/sample3.html" target="_blanck">Пример 3.</a> </p>
            
            <h3>Событие <code>readystatechange</code></h3>
            <p>Обычно объект <code>XMLHttpRequest</code> используется в асинхронном режиме: метод <code>send()</code> возвращает управление сразу же после отправки запроса, по этому методы и свойства, перечисленные выше, не могут использоваться до фактического получения ответа. Что бы определить момент получения ответа, необходимо обрабатывать событие <code>readystatechange</code>, возбуждаемое в объекте <code>XMLHttpRequest</code>. Но, что бы понять, как обрабатывать это событие, необходимо сначала разобраться со свойством <code>readyState</code>.</p>
            <p>Свойство readyState - это целочисленное значение, определяющее код состояния HTTP-запроса; его возможные значения перечислены в таблице. Идентификаторы, указанные в первой колонке, - это константы, определяемые конструктором <code>XMLHttpRequest</code>. </p>
            <table id="ready">
                <tr>
                    <th>Константа</th><th>Значение</th><th>Описание</th>
                </tr>
                <tr>
                    <td>UNSENT</td><td>0</td><td>Метод open() еще не был вызван</td>
                </tr>
                <tr>
                    <td>OPENED</td><td>1</td><td>Метод open() был вызван</td>
                </tr>
                <tr>
                    <td>HEADERS_RECEIVED</td><td>2</td><td>Были получены заголовки</td>
                </tr>
                <tr>
                    <td>LOADING</td><td>3</td><td>Идет прием тела ответа</td>
                </tr>
                <tr>
                    <td>DONE</td><td>4</td><td>Прием ответа завершен</td>
                </tr>
            </table>
            <p>Событие <code>readystatechange</code> возбуждается всякий раз, когда изменяется значение свойства readyState.</p>
            <p><a href="sample/sample4.html" target="_blanck">Пример 4.</a> </p>
 
            <figure class="text-center">
                <img src="img/scheme-of-work-ajax-php.png">
                <figcaption>Схема работы HTML-JS-PHP</figcaption>
            </figure>

    </section>
    
</main>    

<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-C6RzsynM9kWDrMNeT87bh95OGNyZPhcTNXj1NW7RuBCsyN/o0jlpcV8Qyq46cDfL" crossorigin="anonymous"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script>hljs.highlightAll();</script>

</body>
</html>